# 学习笔记

## 数组、链表、跳表

### 几个概念：
* 1.线性表(Linear List)：数组、链表、队列、栈等；非线性表：树、二叉树、图等；
* 2.连续的内存空间、相同类型的数据，所以数组可以随机访问，但对数组进行删除插入，为了保证数组的连续性，就要做大量的数据搬移工作。

### 什么是数组？
数组（Array）是一种线性表数据结构。用一组连续的储存空间来存储一组相同类型的数据。

### 什么是链表？
* 1.和数组一样，链表也是一种线性表。
* 2.从内存结构来看，链表的内存结构是不连续的内存空间，是将一组零散的内存块串联起来，从而进行数据存储的数据结构。
* 3.链表中的每一块内存块被称为节点(Node)。节点除了存储数据外，还记录了链上的下一个节点地址，即后继指针(next)。

### 常见的链表

* 单链表
* 循环链表
* 双向链表
* 双向循环链表

### 数组和链表的区别

#### 基本特点
* 数组：是连续的，有序的，读取快。如果应用需要快速访问数据，很少插入和删除元素，就应该用数组。
* 链表：不是按顺序存储的，查找慢，通过存在元素中的指针联系到一起，每个结点包括两个部分：元素的数据域和下一个节点地址的指针。适合经常插入和删除元素的场景。

#### 复杂度分析
* 链表适合插入、删除，时间复杂度O(1)，查找的时间复杂度是O(n)；
* 数组的查找操作时间复杂度并不是O(1)，即便是排好的数组，用二分查找，时间复杂度也是O(logn)；数组支持随机访问，根据下标随机访问的时间复杂度为O(1)。

#### 应用场景
* 数组应用场景：数据比较少；经常做的运算是按序号访问数据元素；数组更容易实现，任何高级语言都支持；构建的线性表较稳定。
* 链表应用场景：对线性表的长度或者规模难以估计；频繁做插入删除操作；构建动态性比较强的线性表。


### 数组和链表的缺点

#### 数组的缺点
* 若申请的内存空间很大，比如100M，但若内存空间没有100M的连续空间时，则会申请失败，尽管内存可用空间超过100M；
* 大小固定，若存储空间不足，需进行扩容，一旦扩容就需要进行数据复制，而这时非常耗时；

#### 链表的缺点
* 内存空间消耗更大，因为需要额外的空间存储指针信息；
* 对链表进行频繁的插入和删除操作，会导致频繁的内存申请和释放，容易造成内存碎片，如果是Java语言，还可能会造成频繁的GC（Garbage Collection 自动垃圾回收）操作。


### 什么是跳表？
跳表是1989年出现的，基于链表，在链表的基础上增加索引来提高链表查找的效率。
注意：只能用于**元素有序**的情况 。
所以，跳表 （skip list ）对标的是平衡树 （AVL Tree AVL Tree ）和二分查找， 是一种 插入 /删除 /搜索 都是 O(log n) 的数据结构。

### 跳表的优势
它最大的优势是：**原理简单**、**容易实现**、**方便扩展**、**效率更高**。
因此在一些热门的项目里用来替代平衡树，如 Redis edis、Level evelDB等。

### 跳表的时间复杂度分析
索引的高度：logn ，每层索引遍历的结点个数：3
在跳表中查询任意数据的时间复杂度就是：O(logn);

## 栈

### 什么是栈？
* 后进者先出，先进者后出，这就是典型的“栈”结构。
* 从栈的操作特性来看，是一种“操作受限”的线性表，只允许在端**插入**和**删除**数据。

### 为什么需要栈？
栈是一种操作受限的数据结构，其操作特性用数组和链表均可实现。
但是，**任何数据结构都是对特定应用场景的抽象**，数组和链表虽然使用起来更加灵活，却暴露了几乎所有的操作，难免会引发错误操作的风险。
所以：
> 当某个数据集合只涉及在某端插入和删除数据，且满足后进者先出，先进者后出的操作特性时，我们应该首选栈这种数据结构。

### 数组模拟实现栈

```javascript
class Stack {
    constructor(size) {
        this.list = [];
        this.size = size;
        this.count = 0;
    }
    // 入栈
    push(item) {
        if (this.count === this.size) return false;

        this.list[this.count] = item;
        this.count++;
        return true;
    }
    // 出栈
    pop() {
        if (this.count === 0) return null;

        const temp = this.list[this.count - 1];
        this.count--;
        return temp;
    }
    // 是否为空
    isEmpty() {
        return this.count === 0;
    }
    // 栈中数据的数量
    size() {
        return this.count;
    }
    // 返回栈中最近添加的元素而不删除它
    peek() {
        const n = this.count;
        return this.list[n - 1];
    }
}
```

其实JavaScript中数组的原生API就已经很丰富了，自带实现了栈和队列，例如`push`、`shift`、`pop`。


## 队列

### 什么是队列？
* 1.先进者先出，这就是典型的“队列”结构。
* 2.支持两个操作：入队`enqueue()`，放一个数据到队尾；出队`dequeue()`，从队头取一个元素。

> 总而言之，和栈一样，**队列也是一种操作受限的线性表**。

### 队列的延伸

#### 双端队列(Deque)
* 1.简单理解：两端可以进出的 Queue
Deque - double ended queue
* 2.插入和删除都是 O(1) 操作

#### 优先队列(Priority Queue)
* 1.插入操作：O(1)；
* 2.取出操作：O(logN) - 按照元素的优先级取出；
* 3.底层具体实现的数据结构较为多样和复杂：heap、bst、treap；

### 队列的一些应用场景
在JavaScript运行环境中，v8引擎通过**消息队列**维护各类事件和任务的执行。
据我所知的理解，在JavaScript中，虽然规范有提到优先队列，但是目前实际情况并没有实现优先队列，而是通过**宏任务**和**微任务**的方式实现任务的优先级，存在一个是规范，一个是实现的差别。（此处如果理解有误，欢迎大佬指正）

## 栈与队列的关键要点
* 栈(Stack)：先入后出；添加、删除皆为 O(1)
* 队列(Queue)：先入先出；添加、删除皆为 O(1)

