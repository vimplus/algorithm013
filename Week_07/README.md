# 学习笔记

## Trie树（字典树）

### 什么是“Trie 树”？

Trie 树，也叫“字典树”。顾名思义，它是一个树形结构。它是**一种专门处理字符串匹配的数据结构**，用来解决在一组字符串集合中快速查找某个字符串的问题。

### Trie 树的本质

Trie 树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起，来降低查询时间的开销以达到提高效率的目的。
Trie 树的核心思想是：**空间换时间**。

#### 基本性质：

* 结点本身不存完整单词；
* 从根结点到某一结点，路径上经过的字符连接起来，为该结点对应的字符串；
* 每个结点的所有子结点路径代表的字符都不相同；

### Trie的优缺点

* 优点：查询操作会非常高效（查找字符串的时间复杂度是 O(k)，k 表示要查找的字符串的长度）,查询效率优于哈希表；
* 缺点：耗内存，因为每个节点需要存储更多的字节信息；

Trie在一组字符串中查找字符串，它对要处理的字符串有及其严苛的要求：

* 第一：字符串中包含的字符集不能太大。如果字符集太大，那存储空间可能就会浪费很多。即便可以优化，但也要付出牺牲查询、插入效率的代价。
* 第二：要求字符串的前缀重合比较多，不然空间消耗会变大很多（Trie主要用于查询前缀）。
* 第三：实现一棵“Trie树”比较复杂，成本高；
* 第四：通过指针串起来的数据块是不连续的，而 Trie 树中用到了指针，所以，对缓存并不友好，性能上会打个折扣。

### Trie树的应用场景
* 字符串前缀匹配、文本词频统计，如：搜索引擎关键字联想搜索；
* 纠正用户单词拼写错误，如：搜索引擎自动纠正关键词；
* 过滤敏感词；

### 如何实现 Trie 树
Trie 树主要有两个操作：

* 一个是将字符串集合构造成 Trie 树。这个过程分解开来的话，就是一个将字符串插入到 Trie 树的过程。
* 一个是在 Trie 树中查询一个字符串。

代码实现：(见Trie.js)

## 并查集

### 适用场景
* 组团、配对；
* Group or not ?

### 基本操作
* `makeSet(s)`：建立一个新的并查集，其中包含 s 个单元素集合。
* `unionSet(x, y)`：把元素 x 和元素 y 所在的集合合并，要求 x 和 y 所在的集合不相交，如果相交则不合并。
* `find(x)`：找到元素 x 所在的集合的代表，该操作也可以用于判断两个元素是否位于同一个集合，只要将它们各自的代表比较一下就可以了。

## 剪枝
剪枝：顾名思义，就是删去一些不重要的节点，来减小计算或搜索的复杂度。
剪枝在很多算法中都有很好的应用，如：搜索算法，决策树，神经网络，数据库的设计等。

* 在搜索算法中，通过分析搜索过程中的分支，提前将**比较差的分支**或者说**次优的分支**剪掉（过滤掉），可以减小搜索范围，提高搜索效率。
* 在决策树和神经网络中，剪枝可以有效缓解过拟合问题并减小计算复杂度；

### 剪枝策略的寻找方法

* 微观方法：从问题本身出发，发现剪枝条件
* 宏观方法：从整体出发，发现剪枝条件。
* 注意提高效率，这是关键，最重要的。

### 剪枝的原则
* 正确性
* 准确性
* 高效性

## 双向BFS
双向BFS（Two End BFS）：顾名思义，就是从两端同时进行BFS，以提高搜索效率；

## 启发式搜索

A* Search: 在BFS的基础上引入优先队列，并存在估价函数。

### 估价函数

启发式函数： h(n)，它用来评价哪些结点最有希望的是一个我们要找的结点，h(n) 会返回一个非负实数,也可以认为是从结点n的目标结点路径的估计成本。

启发式函数是一种告知搜索方向的方法。它提供了一种明智的方法来猜测哪个邻居结点会导向一个目标。

> 估价函数: h(current_state) = distance(current_state, target_state)

## AVL树与红黑树

### 什么是“平衡二叉查找树”？
平衡二叉树的严格定义是这样的：二叉树中任意一个节点的左右子树的高度相差不能大于 1。

平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。

### AVL树
AVL 树是一种高度平衡的二叉树，所以查找的效率非常高，但是，有利就有弊，AVL 树为了维持这种高度的平衡，就要付出更多的代价。每次插入、删除都要做调整，就比较复杂、耗时。所以，对于有频繁的插入、删除操作的数据集合，使用 AVL 树的代价就有点高了。

### 如何定义一棵“红黑树”？
红黑树的英文是“Red-Black Tree”，简称 R-B Tree。它是一种不严格的平衡二叉查找树（又称“近似平衡二叉树”）。

顾名思义，红黑树中的节点，一类被标记为黑色，一类被标记为红色。除此之外，一棵红黑树还需要满足这样几个要求：

* 根节点是黑色的；
* 每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据（为了简化红黑树的代码实现而设置的）；
* 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；
* 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；

### 红黑树的特点

* 红黑树的高度近似 log2n，所以它是近似平衡，插入、删除、查找操作的时间复杂度都是 O(logn)。
* 性能非常稳定，常用于动态插入、删除、查找数据的场景

红黑树只是做到了近似平衡，并不是严格的平衡，所以在维护平衡的成本上，要比 AVL 树要低。
所以，红黑树的插入、删除、查找各种操作性能都比较稳定。对于工程应用来说，要面对各种异常情况，为了支撑这种工业级的应用，我们更倾向于这种性能稳定的平衡二叉查找树。

