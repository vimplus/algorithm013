# 学习笔记


## 分治与回溯

分治与回溯其实本质上是递归，只不过它们是递归的一个细分类。
分治和回溯是一种特殊的递归（或者说是较为复杂的递归）。

### 重复性、分解问题
不管是递归、分治、回溯，还是其他的方式，本质上就是**找重复性**以及**分解问题**，和**最后组合每个子问题的结果**，重复性分为：

* 最近的重复性（分治、回溯等等）
* 最优的重复性（动态规划）

### 分治的思想
分治算法（divide and conquer）的核心思想其实就是四个字：**分而治之**，就是将一个大问题拆分n个子问题去解决。

主要就是将一个大问题拆分n个规模较小，并且结构与原问题相似的子问题，**递归**地解决这些子问题，然后再合并其结果，就得到原问题的解。

> 分治与递归的区别就是**分治需要在最后把所有的子问题的结果组合成一个总的结果。**

分治算法的递归实现中，每一层递归都会涉及这样三个操作：
* 分解：将原问题分解成一系列子问题；
* 解决：递归地求解各个子问题，若子问题足够小，则直接求解；
* 合并：将子问题的结果合并成原问题。

### 回溯

回溯（backtrack）的思想就是**通过递归寻找所有的问题的解，最终找到满足期望的解**，有点类似枚举搜索。

> 为了有规律地枚举所有可能的解，避免遗漏和重复，我们把问题求解的过程分为多个阶段。每个阶段，我们都会面对一个岔路口，我们先随意选一条路走，当发现这条路走不通的时候（不符合期望的解），就回退到上一个岔路口，另选一种走法继续走。

在通过反复递归寻找各种问题的结果后，可能存在两种情况：
* 找到了一个可能存在的解；
* 在尝试了所有可能的分步方法之后宣告该问题没有答案。

在最坏的情况下，回溯法会导致一次复杂度为指数级的时间复杂度计算。

#### 回溯的代码模板

```javascript

function fn(params) {
    let result = [];
    function backtrack(路径, 选择列表) {
        if (满足结束条件) {
            result.push(路径);   // 添加路径
            return;
        }

        // 选择在选择列表中
        for (const select in selectList) {
            // 做选择
            backtrack(way, selectList);
            // 撤销选择
        }
    }
}
```

回溯的核心就是for循环里面的递归，在递归调用之前【做选择】，在递归调用之后【撤销选择】。


