# 学习笔记

## 递归
* 1.递归是一种非常高效、简洁的编码技巧，一种应用非常广泛的算法，比如DFS深度优先搜索、前中后序二叉树遍历等都是使用递归。
* 2.方法或函数调用自身的方式称为递归调用，**调用称为递，返回称为归**。

> 递归的本质其实就是**循环**，递归通过函数体来进行循环。

汇编的循环代码其实和递归有异曲同工之处，循环和递归没有明显的边界。

### 递归的要点（盗墓空间）
* 向下进入到不同的梦境（不同的层级），向上又回到原来的一层；
* 通过声音（参数）同步回到上层；
* 每一层的环境和周围的人物都是一份拷贝，主角等几个关键人物穿越不同层级的梦境（发生和携带变化）；

#### 什么样的问题可以用递归解决呢？
一个问题只要同时满足以下3个条件，就可以用递归来解决：

* 1.问题的解可以分解为几个子问题的解。何为子问题？就是数据规模更小的问题；
* 2.问题与子问题，除了数据规模不同，**求解思路完全一样**；
* 3.存在递归终止条件。

### 递归代码模板

```javascript
// 递归模板
function recursion(level, maxLevel, param) {
    // terminator（终结者）- 先把[施瓦辛格]装进去
    if (level > maxLevel) {
        // process result;
        return 
    }

    // process current logic（当前层逻辑）
    process(level, param);

    // drill down（下探到下一层）
    recursion(level + 1, newParam)

    // restore current status（清扫当前层）
}
```

### 经典递归示例（斐波那契数）

```javascript
/**
 * @param {number} N
 * @return {number}
 */
var factorial = function(N) {
    if (N <= 1) return 1;
    return N * fib(N - 1);
};
```

### 思维要点
* 不要人肉进行递归（最大误区）
* 找到最近最简方法，将其拆解成可重复解决的问题（重复子问题）
* 数学归纳法思维

### 为什么使用递归？(递归的优缺点)

* 1.优点：代码的表达力很强，写起来简洁。
* 2.缺点：空间复杂度高、有堆栈溢出风险、存在重复计算、过多的函数调用会耗时较多等问题。

### 树的面试题解法一般都是递归为什么？

* 1.节点的定义
* 2.重复性（自相似性）

### 递归常见问题及解决方案

* 1.警惕堆栈溢出：可以声明一个全局变量来控制递归的深度，从而避免堆栈溢出。
* 2.警惕重复计算：通过某种数据结构来保存已经求解过的值，从而避免重复计算。


## 分治与回溯

分治与回溯其实本质上是递归，只不过它们是递归的一个细分类。
分治和回溯是一种特殊的递归（或者说是较为复杂的递归）。

### 重复性、分解问题
不管是递归、分治、回溯，还是其他的方式，本质上就是**找重复性**以及**分解问题**，和**最后组合每个子问题的结果**，重复性分为：

* 最近的重复性（分治、回溯等等）
* 最优的重复性（动态规划）

### 分治的思想
分治算法（divide and conquer）的核心思想其实就是四个字：**分而治之**，就是将一个大问题拆分n个子问题去解决。

主要就是将一个大问题拆分n个规模较小，并且结构与原问题相似的子问题，**递归**地解决这些子问题，然后再合并其结果，就得到原问题的解。

> 分治与递归的区别就是**分治需要在最后把所有的子问题的结果组合成一个总的结果。**

分治算法的递归实现中，每一层递归都会涉及这样三个操作：
* 分解：将原问题分解成一系列子问题；
* 解决：递归地求解各个子问题，若子问题足够小，则直接求解；
* 合并：将子问题的结果合并成原问题。

### 回溯

回溯（backtrack）的思想就是**通过递归寻找所有的问题的解，最终找到满足期望的解**，有点类似枚举搜索。

> 为了有规律地枚举所有可能的解，避免遗漏和重复，我们把问题求解的过程分为多个阶段。每个阶段，我们都会面对一个岔路口，我们先随意选一条路走，当发现这条路走不通的时候（不符合期望的解），就回退到上一个岔路口，另选一种走法继续走。

在通过反复递归寻找各种问题的结果后，可能存在两种情况：
* 找到了一个可能存在的解；
* 在尝试了所有可能的分步方法之后宣告该问题没有答案。

在最坏的情况下，回溯法会导致一次复杂度为指数级的时间复杂度计算。

#### 回溯的代码模板

```javascript
function fn(selectList) {
    let result = [];
    function backtrack(路径, 选择列表) {
        if (满足结束条件) {
            result.push(路径);   // 添加路径
            return;
        }

        // 选择在选择列表中
        for (const select in selectList) {
            // 做选择
            backtrack(way, selectList);
            // 撤销选择
        }
    }

    backtrack(选择列表);
    return result;
}
```

回溯的核心就是for循环里面的递归，在递归调用之前【做选择】，在递归调用之后【撤销选择】。


