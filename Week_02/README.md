# 学习笔记

## 哈希表、集合、映射
### 什么是哈希表？

哈希表（Hash table），也叫散列表，是根据**关键码值**（Key value）而直接进行访问的数据结构。
它通过把**关键码值映射到表中一个位置**来访问记录，以加快查找的速度。
这个映射函数叫作**散列函数**（Hash Function），存放记录的数组叫作**哈希表**（或散列表）。

哈希表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。

### 散列函数
散列函数，顾名思义，它是一个函数。我们可以把它定义成 hash(key)，其中 key 表示元素的键值，hash(key) 的值表示经过散列函数计算得到的散列值。

### 如何解决散列冲突？
#### 方法一：开放寻址法
开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。

* 线性探测
* 二次探测
* 双重散列

#### 方法二：链表法
在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，将所有散列值**相同的元素都放到相同槽位对应的链表**中。

##### 总结：
* 当数据量比较小、装载因子小的时候，适合采用开放寻址法。
* 基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。

### 工程实践
* 电话号码簿
* 用户信息表
* 缓存（LRU Cache）
* 键值对存储（Redis）

### JavaScript中的实践
* Map
* Set
* Object

## 树、二叉树、二叉搜索树
### 树
“树”这种数据结构真的很像我们现实生活中的“树”，这里面每个元素我们叫做“**节点**”；用来连接相邻节点之间的关系，我们叫做“父子关系”

**链表**是特殊化的**树**，**树**是特殊化的**图**。

### 二叉树

#### 二叉树遍历 Pre-order/In-order/Post-order
* 前序（Pre-order）： 根-左-右
* 中序（In-order）：  左-根-右
* 后序（Post-order）：左-右-根

## 堆和二叉堆



## 图