# 学习笔记

## 哈希表、集合、映射
### 什么是哈希表？

哈希表（Hash table），也叫散列表，是根据**关键码值**（Key value）而直接进行访问的数据结构。
它通过把**关键码值映射到表中一个位置**来访问记录，以加快查找的速度。
这个映射函数叫作**散列函数**（Hash Function），存放记录的数组叫作**哈希表**（或散列表）。

哈希表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。

### 散列函数
散列函数，顾名思义，它是一个函数。我们可以把它定义成 hash(key)，其中 key 表示元素的键值，hash(key) 的值表示经过散列函数计算得到的散列值。

### 如何解决散列冲突？
#### 方法一：开放寻址法
开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。

* 线性探测
* 二次探测
* 双重散列

#### 方法二：链表法
在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，将所有散列值**相同的元素都放到相同槽位对应的链表**中。

##### 总结：
* 当数据量比较小、装载因子小的时候，适合采用开放寻址法。
* 基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。

### 工程实践
* 电话号码簿
* 用户信息表
* 缓存（LRU Cache）
* 键值对存储（Redis）

### JavaScript中的应用
* Map
* Set
* Object

## 树、二叉树、二叉搜索树

### 树
“树”这种数据结构真的很像我们现实生活中的“树”，这里面每个元素我们叫做“**节点**”；用来连接相邻节点之间的关系，我们叫做“父子关系”

我们把共用同一个父节点的节点之间互称为**兄弟节点**，把没有父节点的节点叫做**根节点**，我们把**没有子节点的节点**叫做**叶子节点**或者叶节点，

树有三个比较相似的概念：高度（Height）、深度（Depth）、层（Level）。

* “高度”这个概念，其实就是从下往上度量；
* “深度”这个概念在生活中是从上往下度量的；
* “层数”跟深度的计算类似，不过，计数起点是 1，也就是说根节点位于第 1 层。；

> **链表**是特殊化的**树**，**树**是特殊化的**图**。

### 二叉树
二叉树，顾名思义，每个节点最多有两个“叉”，也就是两个子节点，分别是**左子节点**和**右子节点**。不过，二叉树并不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点。

#### 二叉树遍历 Pre-order/In-order/Post-order
* 前序（Pre-order）： 根-左-右
* 中序（In-order）：  左-根-右
* 后序（Post-order）：左-右-根

### 二叉搜索树

二叉搜索树，也称二叉排序树、有序二叉树（Ordered Binary Tree）、排序二叉树（Sorted Binary Tree），是指一棵**空树或者具有下列性质的二叉树**：
1. **左**子树上**所有结点**的值均**小于**它的**根结点**的值；
2. **右**子树上**所有结点**的值均**大于**它的**根结点**的值；
3. 以此类推：左、右子树也分别为**二叉搜索树**。（这就是重复性！）

#### 树的面试题解法一般都是递归为什么？

* 1.节点的定义
* 2.重复性（自相似性）

## 堆和二叉堆
### 堆
**堆是一种特殊的树**。只要满足以下两点，它就是一个堆：

* 堆是一个完全二叉树；
* 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。

**堆是一种可以迅速找到一堆数中的最大值或者最小值的数据结构。**

### 堆的类别

* 大顶堆（大根堆）：根节点最大的堆；
* 小顶堆（小根堆）：根节点最小的堆；

常见的还有二叉堆，斐波那契堆等。

### 常见的API
假设是大顶堆，常见的操作（API）：

* findMax: O(1)
* deleteMax: O(logN)
* insert: O(logN) / O(1)

### 二叉堆
通过**完全二叉树**来实现。（注意：不是二叉搜索树）

> 注意：二叉堆是堆（优先队列：PriorityQueue）的一种常见且简单的实现，但并不是最优的实现。

#### 二叉堆（大顶堆）的性质

* 1.是一颗完全数；
* 2.树的任意节点的值总是 >= 其子节点的值；

#### 二叉堆的实现细节
* 1.二叉堆一般通过“数组”来实现；
* 2.假设“第一个元素”在数组中的索引为0的话，则父节点和子节点的位置关系如下：

    - 索引为 i 的**左孩子的索引**是：2i + 1 =>（左节点索引是**基数**）;
    - 索引为 i 的**右孩子的索引**是：2i + 2 =>（右节点索引是**偶数**）;
    - 索引为 i 的**父节点的索引**是：Math.floor((i - 1) / 2);
    - 根节点（堆顶元素）是：arr[0];

* 3.insert：堆的插入操作(heapifyUp):
    - 新元素一律先**插入到堆的尾部**；
    - 依次向上调整整个堆的结构，一直到根节点即可（重建堆）；

* 4.deleteMax：删除堆顶的操作(heapifyDown):
    - 首先将堆尾元素替换到顶部（顶部的换到了尾部，再将尾部删除，即顶部被替代删除掉）；
    - 依次从根部向下调整整个堆的结构，一直到堆尾即可（重建堆）；

## 图

### 图的属性
* Graph(V, E);
* V - vertex: 点
    - 1.度：入度和出度
    - 2.点与点之间: 连通与否

* E - edge: 边
    - 1.有向和无向（单行线）
    - 权重（边长）

### 图的分类与表示
* 无向无权图
* 有向无权图
* 无向有权图

### 基于图相关的算法
* DFS - 递归写法
* BFS


